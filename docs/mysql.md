### 1.mysql是否在扫描额外的记录

> 最简单的衡量查询开销的几个指标：
  * 响应时间 
   
     包括服务时间和排队时间
  * 扫描的行数 
  
     较短的行的访问速度更快  内存中的行比磁盘中的行的访问速度要快
  * 返回的行数
  * 扫描的行数和访问类型
   
    Using where 通过where条件
```
    1.在索引中使用where条件过滤不匹配记录，这是在存储引擎层完成的
    2.使用索引覆盖扫描（Extra列出现Using idnex） 直接从索引中过滤不需要的记录并返回命中结果 这是在mysql服务层完成的
    3.mysql先从数据表读出记录然后服务器层过滤 
```
 > 如果发现查询需要扫描大量的数据但是只返回少数的行，可以尝试通过以下技巧优化：
  * 使用索引覆盖扫描
  * 改变库表结构 例如使用单独的汇总表
  * 重写这个查询 尽量让mysql优化器能够以更优化的方式执行这个查询   
  
### 2.重构查询的方式
> 一个复杂查询还是多个简单查询

> 切分查询  

>分解关联查询
```
 1.让缓存的效率更高
 2.查询分解后 执行单个查询可以减少锁的竞争
 3.在应用层做关联，更容易对数据库进行拆分，更容易做到高性能和可扩展
 4.提升查询本身效率
 5.可以减少冗余记录的查询
 6.哈希关联 与 mysql的嵌套关联
```

### 3.查询执行的基础
> 查询执行过程
```aidl
   1. 客户端发送一条查询给服务器
   2. 服务器检查缓存，命中缓存则直接返回缓存中数据，否则进入下一阶段。
   3. 服务器端sql解析、预处理，再由优化器生成对应的执行计划
   4. mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询
   5. 将结果返回给客户端
```
> MySQL客户端\服务端通信协议
 >
 * 查询状态
 ```aidl
使用show full processlist命令查看一个mysql链接状态
1. sleep 
   线程正在等待客户端发送新的请求
2.Query
   线程正在执行查询或者正在将结果发送给客户端
3.Locked
    该线程正在等待表锁（MySQL服务器层）
4.Analyzing and statistics
    正在收集存储引擎的统计信息，并生成查询的执行计划
5.Copying to tmp disk [on disk]
    正在执行查询 并且将结果复制到一个临时表中,一般要么是在做group by操作，要么是文件排序操作，或者是UNION操作。
如果后面有on disk标记 表明正在将一个内存临时表放到磁盘上
6.Sorting result
    线程正在对结果集进行排序
7.Sending Data
    线程在多个状态之间传送数据或者正在生成结果集或者正在向客户端返回数据
```